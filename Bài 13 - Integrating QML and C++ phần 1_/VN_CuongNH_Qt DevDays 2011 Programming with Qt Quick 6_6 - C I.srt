1
00:00:05,930 --> 00:00:08,809
Được rồi. Tôi sẽ trình bày về

2
00:00:08,809 --> 00:00:12,270
QML và C++ cùng cách để chúng có thể hoạt động

3
00:00:12,270 --> 00:00:15,690
với nhau. Như tôi đã đề cập, bài giảng này

4
00:00:15,690 --> 00:00:18,119
thực ra được rút gọn từ một khóa học kéo dài ba ngày

5
00:00:18,119 --> 00:00:21,500
về cách viết những ứng dụng trong

6
00:00:21,500 --> 00:00:25,950
QML và Qt. Cho nên có rất nhiều thứ

7
00:00:25,950 --> 00:00:28,290
đã được cô đặc lại và có vài thứ được

8
00:00:28,290 --> 00:00:29,970
bỏ đi. Tôi đã xem qua bài giảng này

9
00:00:29,970 --> 00:00:32,159
và một thứ mà tôi đã bỏ đi là

10
00:00:32,159 --> 00:00:36,680
cách export (xuất) nhanh chóng và tạm thời

11
00:00:36,680 --> 00:00:41,129
các đối tượng C++ vào môi trường QML.

12
00:00:41,129 --> 00:00:43,949
Nếu mọi người không thấy vấn đề gì

13
00:00:43,949 --> 00:00:46,109
thì tôi sẽ thay đổi một chút,

14
00:00:46,109 --> 00:00:48,559
rồi chuyển sang những ghi chép cho

15
00:00:48,559 --> 00:00:51,300
phần trình bày của tôi vào ngày mai và chúng ta sẽ

16
00:00:51,300 --> 00:00:53,100
tìm hiểu qua một phần ngắn về việc làm thế nào

17
00:00:53,100 --> 00:00:55,620
nếu bạn tạo ra một đối tượng (object) trong C++, ví dụ như

18
00:00:55,620 --> 00:00:58,140
bạn tạo một con trỏ (pointer) nào đó, thì bạn có thể

19
00:00:58,140 --> 00:01:03,140
export con trỏ đó vào QML.

20
00:01:03,140 --> 00:01:05,459
Bài giảng này thực sự ăn khớp với

21
00:01:05,459 --> 00:01:08,640
việc tạo ra một thứ mà bạn biết như

22
00:01:08,640 --> 00:01:12,960
biểu đồ hình bánh hay biểu đồ hình cột trong QML.

23
00:01:12,960 --> 00:01:14,430
Và nền tảng của thứ đó thì

24
00:01:14,430 --> 00:01:16,890
thực ra được vẽ bằng C++ mà

25
00:01:16,890 --> 00:01:26,070
cũng rất hữu dụng. Vậy hãy tiếp tục và

26
00:01:26,070 --> 00:01:29,730
nếu mọi người đưa tôi

27
00:01:29,730 --> 00:01:30,270
danh thiếp

28
00:01:30,270 --> 00:01:32,760
sau buổi học thì tôi có thể

29
00:01:32,760 --> 00:01:35,190
gửi cho các bạn bài giảng này.

30
00:01:35,190 --> 00:01:37,620
Tôi nghĩ hình như các bạn đã có những bài giảng này rồi.

31
00:01:37,620 --> 00:01:40,200
Chúng được sao chép vào các USB trong gói quà tặng.

32
00:01:40,200 --> 00:01:42,270
Nếu bạn chưa có bài giảng thì tôi cũng

33
00:01:42,270 --> 00:01:43,350
có thể gửi chúng cho bạn. QML thực chất

34
00:01:43,350 --> 00:01:46,350
là một nền tảng nguồn mở (open source) do Nokia

35
00:01:46,350 --> 00:01:51,330
phát triển. Cho nên bạn có thể lấy những đối tượng mà bạn

36
00:01:51,330 --> 00:01:54,830
tạo ra trong C++ và export chúng vào

37
00:01:54,830 --> 00:01:58,080
môi trường thực thi của QML, là nơi

38
00:01:58,080 --> 00:02:00,870
chúng sẽ chuyển thành các biến (variable).

39
00:02:00,870 --> 00:02:03,210
Bạn có thể tạo ra

40
00:02:03,210 --> 00:02:05,610
con trỏ mô hình mục trừu tượng (abstract item model pointer)
rồi export nó, hoặc bạn có thể

41
00:02:05,610 --> 00:02:07,710
tạo ra con trỏ QObject rồi

42
00:02:07,710 --> 00:02:12,569
export nó, và cách khác là bạn có thể

43
00:02:12,569 --> 00:02:15,780
export những kiểu (type) cho đối tượng (instance)

44
00:02:15,780 --> 00:02:18,240
có thể gọi được trong QML. Vì vậy

45
00:02:18,240 --> 00:02:19,620
có một chút khác biệt với

46
00:02:19,620 --> 00:02:23,430
những thứ mà bạn có thể tạo trong C++. Giả sử bạn

47
00:02:23,430 --> 00:02:26,460
tạo ra chúng trong hàm main rồi bạn có thể

48
00:02:26,460 --> 00:02:29,880
export chúng vào QML là bạn có thể tạo ra

49
00:02:29,880 --> 00:02:33,300
con trỏ QObject bất kì. Bạn có thể tạo ra nó trong

50
00:02:33,300 --> 00:02:37,250
C++ rồi export nó vào trong môi trường QML.

51
00:02:37,250 --> 00:02:41,220
Các thuộc tính (property) trở thành

52
00:02:41,220 --> 00:02:45,870
các biến (variable). Các slot thì bây giờ là các hàm (function).

53
00:02:45,870 --> 00:02:47,940
Đôi khi bạn thiết kế chương trình của bạn trong C++

54
00:02:47,940 --> 00:02:51,750
thì nó có thể được sử dụng trong C++ và QML.

55
00:02:51,750 --> 00:02:54,060
Có vài thứ như các function có

56
00:02:54,060 --> 00:02:56,310
kiểu trả về (return type) mà bạn thường không

57
00:02:56,310 --> 00:02:58,680
muốn trở thành các slot, mà bạn muốn chúng

58
00:02:58,680 --> 00:03:01,740
có thể gọi được (INVOKABLE) từ QML. Bạn có thể sử dụng

59
00:03:01,740 --> 00:03:04,410
macro Q_INVOKABLE ở trước

60
00:03:04,410 --> 00:03:06,540
các signal hơn là đặt nó vào một

61
00:03:06,540 --> 00:03:10,680
slot. Bạn có thể export một QList

62
00:03:10,680 --> 00:03:13,560
của QObject, và cách này
có thể được sử dụng như là một

63
00:03:13,560 --> 00:03:16,260
mô hình dữ liệu nhanh và tạm
(quick and dirty). Tuy nhiên, bạn

64
00:03:16,260 --> 00:03:19,320
có thể chèn hay nối thêm vào danh sách (list). Đó là

65
00:03:19,320 --> 00:03:22,200
một danh sách được tổng hợp nhanh và tạm
về các mục (item) và

66
00:03:22,200 --> 00:03:24,450
thứ có tác động lớn nhất mà bạn có thể

67
00:03:24,450 --> 00:03:27,900
tạo ra và export từ C++ là con trỏ

68
00:03:27,900 --> 00:03:30,930
mô hình mục trừu tượng. Bạn có thể tạo ra con trỏ đó,

69
00:03:30,930 --> 00:03:34,050
tạo ra tất cả dữ liệu trong C++, tạo ra

70
00:03:34,050 --> 00:03:37,050
giao diện (interface) cho dữ liệu trong C++ rồi chỉ việc

71
00:03:37,050 --> 00:03:41,940
export nó vào QML và sử dụng nó ở đó. Bạn

72
00:03:41,940 --> 00:03:44,850
cũng có thể export QVariant instance bất kỳ,

73
00:03:44,850 --> 00:03:46,590
mà là một vỏ bọc (wrapper),

74
00:03:46,590 --> 00:03:49,050
về cơ bản là void* và nó

75
00:03:49,050 --> 00:03:51,240
trở thành một kiểu giá trị đơn giản trong QML.

76
00:03:51,240 --> 00:03:53,190
Đây có lẽ là điều hiếm khi export nhất.

77
00:03:53,190 --> 00:03:55,520
Vâng?

78
00:04:00,230 --> 00:04:06,200
Ồ, vâng. Hóa ra

79
00:04:06,200 --> 00:04:08,610
việc chuyển đổi vấn đề với sự khác biệt là

80
00:04:08,610 --> 00:04:10,319
bạn chỉ có thể biến đổi chúng thành hay

81
00:04:10,319 --> 00:04:14,099
từ item cụ thể của bạn. Và nếu

82
00:04:14,099 --> 00:04:16,410
trong QML, thì bạn không thể thực hiện chuyển đổi giống như

83
00:04:16,410 --> 00:04:18,660
từ một item tùy chỉnh thành một sự biến đổi. Thật ra bạn

84
00:04:18,660 --> 00:04:20,639
chỉ có thể duyệt (pass) nó vào rồi duyệt nó

85
00:04:20,639 --> 00:04:24,120
trở lại C++ để nó được xử lý. Nếu bạn

86
00:04:24,120 --> 00:04:26,880
muốn có một item là cấu trúc (struct) được export

87
00:04:26,880 --> 00:04:30,120
vào chỗ bạn có, ví dụ như myVariable.name hay

88
00:04:30,120 --> 00:04:32,790
myVariable.title thì nó phải là một

89
00:04:32,790 --> 00:04:40,440
con trỏ QObject. Nhưng

90
00:04:40,440 --> 00:04:43,590
đó là mẹo và thậm chí trong C++ hay QT,

91
00:04:43,590 --> 00:04:47,220
không có thứ gì mà bạn không thể ghi đè

92
00:04:47,220 --> 00:04:52,639
vào những kiểu phức tạp.

93
00:04:56,780 --> 00:05:00,210
Đó là điều mà bạn sẽ muốn thực hiện và

94
00:05:00,210 --> 00:05:02,190
có ví dụ sau vài slide nữa.

95
00:05:02,190 --> 00:05:05,760
Nếu bạn cần bọc thứ gì đó

96
00:05:05,760 --> 00:05:08,220
hoạt động dưới dạng biến thể (variant) trong C++

97
00:05:08,220 --> 00:05:09,570
và bạn chuyển đổi hay đảo ngược, thì đó là một

98
00:05:09,570 --> 00:05:12,000
cấu trúc dữ liệu khó lường (deep data structure)
mà bạn có thể bọc cấu trúc đó vào

99
00:05:12,000 --> 00:05:18,120
QObject rồi duyệt nó.

100
00:05:18,120 --> 00:05:19,410
Nhưng chúng ta sẽ tập trung vào

101
00:05:19,410 --> 00:05:21,120
con trỏ QObject thông qua abstract item model.

102
00:05:21,120 --> 00:05:27,210
Ở đây, ta có một phép gán.

103
00:05:27,210 --> 00:05:29,760
Ta gán rotation bằng biểu thức gồm value

104
00:05:29,760 --> 00:05:32,310
min và max. Đây có thể là

105
00:05:32,310 --> 00:05:34,380
các biến là instance. Những property

106
00:05:34,380 --> 00:05:36,510
của chúng và QML hay những thứ lớn hơn

107
00:05:36,510 --> 00:05:40,919
được đẩy từ C++, cho nên QML

108
00:05:40,919 --> 00:05:44,310
có thể gọi ngược (call back) về C++ bằng cách gọi

109
00:05:44,310 --> 00:05:47,070
những function mà là các slot hay sử dụng

110
00:05:47,070 --> 00:05:49,560
Q_INVOKABLE. Bạn có thể gọi

111
00:05:49,560 --> 00:05:54,360
backEnd.doSomething. Đây là cách bạn

112
00:05:54,360 --> 00:05:57,780
tạo ra một đối tượng tên là Car. Và đối tượng Car

113
00:05:57,780 --> 00:06:00,450
có một danh sách các cảm biến (sensor) có thể lấy

114
00:06:00,450 --> 00:06:04,650
sensorValue, sensorUnits, sensorMin và sensorMax.

115
00:06:04,650 --> 00:06:06,990
Chìa khóa ở đây là ta có QObject,

116
00:06:06,990 --> 00:06:09,840
macro Q_OBJECT, ta sử dụng Q_ENUMS và ta

117
00:06:09,840 --> 00:06:11,080
có Sensor.

118
00:06:11,080 --> 00:06:16,930
Đây là một đoạn C++.

119
00:06:16,930 --> 00:06:19,870
Vấn đề với C++ và QML là

120
00:06:19,870 --> 00:06:23,050
có thể có vài sự xung đột. Một bên là QML không

121
00:06:23,050 --> 00:06:26,199
thích sử dụng enum chút nào, đặc biệt là khi bạn

122
00:06:26,199 --> 00:06:29,199
export instance không có type nào.

123
00:06:29,199 --> 00:06:31,690
Có một cách để sử dụng enum khi bạn

124
00:06:31,690 --> 00:06:33,460
export kiểu (type). Nhưng khi bạn

125
00:06:33,460 --> 00:06:36,849
export một instance, thì nó khó hơn nhiều,

126
00:06:36,849 --> 00:06:40,150
tuy nhiên bạn có thể sử dụng một
đối tượng vỏ bọc (wrapper object).

127
00:06:40,150 --> 00:06:42,340
Ví dụ như ở đây, tôi sẽ

128
00:06:42,340 --> 00:06:46,199
export CarSensorProxy này vào QML.

129
00:06:46,199 --> 00:06:50,190
Nó có một đống Q_PROPERTY.

130
00:06:50,190 --> 00:06:52,960
Đây là đối tượng hạng xoàng (flyweight object).

131
00:06:52,960 --> 00:06:55,389
Nó sẽ vào trong hàm tạo (constructor) của nó, lấy vào

132
00:06:55,389 --> 00:06:57,460
một con trỏ cho car và sensor.

133
00:06:57,460 --> 00:07:02,199
Nó sẽ theo dõi và rồi interface của chúng ta sẽ

134
00:07:02,199 --> 00:07:04,300
trở thành giá trị min và max

135
00:07:04,300 --> 00:07:10,389
của property trong C++. Chúng ta sẽ tạo

136
00:07:10,389 --> 00:07:14,199
QDeclarativeView mà sẽ

137
00:07:14,199 --> 00:07:16,659
cho ta engine để QML

138
00:07:16,659 --> 00:07:18,759
hoạt động trong đó cùng với cửa sổ

139
00:07:18,759 --> 00:07:21,580
mà nó sẽ chạy trong đó rồi ta setSource.

140
00:07:21,580 --> 00:07:23,650
Ở đây, tôi có một dự án (project) tên là

141
00:07:23,650 --> 00:07:25,150
MegaDash, đây sẽ là một bảng điều khiển (dashboard)

142
00:07:25,150 --> 00:07:28,060
cho xe ô tô của tôi. Và chúng ta
có thể hiển thị nó cũng như có thể

143
00:07:28,060 --> 00:07:31,599
trích xuất nó. Bây giờ đó là điều diễn ra trong

144
00:07:31,599 --> 00:07:34,210
đoạn comment có nội dung:" Export C++"

145
00:07:34,210 --> 00:07:35,199
"instances here."

146
00:07:35,199 --> 00:07:38,349
"See next slide". Giữa lúc tạo

147
00:07:38,349 --> 00:07:41,620
view và setSource, bạn có thể

148
00:07:41,620 --> 00:07:44,860
export bao nhiêu đối tượng là tùy bạn muốn.

149
00:07:44,860 --> 00:07:47,740
Ví dụ như trong vòng lặp for khổng lồ export hàng trăm

150
00:07:47,740 --> 00:07:51,099
sensor này. Ở đây tôi đang lặp đi lặp lại

151
00:07:51,099 --> 00:07:54,400
enum trong class Car cho Car Sensor của nó, và

152
00:07:54,400 --> 00:08:01,360
tôi đang tạo các con trỏ CarSensorProxy* rồi tôi

153
00:08:01,360 --> 00:08:02,889
cho car trong sensor vào con trỏ này. Sau đó

154
00:08:02,889 --> 00:08:06,159
tôi export vào view. Bạn sẽ có

155
00:08:06,159 --> 00:08:09,460
view.rootContext, và bạn export

156
00:08:09,460 --> 00:08:12,039
ContextProperty. Có lẽ đây là một trong những

157
00:08:12,039 --> 00:08:14,169
hàm được đặt tên mơ hồ nhất.

158
00:08:14,169 --> 00:08:17,529
Nhưng việc này sẽ export một C++

159
00:08:17,529 --> 00:08:19,839
instance thành đối tượng trong engine thực thi (execution engine).

160
00:08:19,839 --> 00:08:22,810
Tham số thứ nhất là một xâu kí tự (string)

161
00:08:22,810 --> 00:08:23,710
mà là

162
00:08:23,710 --> 00:08:25,750
tên của biến, mà sẽ được

163
00:08:25,750 --> 00:08:29,320
sử dụng trong QML. Do tôi sử dụng vòng lặp for ở đây,

164
00:08:29,320 --> 00:08:32,350
nên car của tôi đủ thông minh để trả về cho tôi

165
00:08:32,350 --> 00:08:35,110
một xâu kí tự là tên của

166
00:08:35,110 --> 00:08:38,770
một sensor cụ thể. Rồi tôi export tên

167
00:08:38,770 --> 00:08:42,549
cùng con trỏ. Cho nên bây giờ

168
00:08:42,549 --> 00:08:47,280
thật kì diệu là trong ứng dụng của tôi, tôi có RPM
(Round per minute - Số vòng quay trong một phút),

169
00:08:47,280 --> 00:08:51,280
tốc độ, áp suất nhiên liệu, áp suất dầu.

170
00:08:51,280 --> 00:08:54,600
Không chỉ có vậy mà tôi còn có thể có

171
00:08:54,600 --> 00:08:57,610
oilPressure.minimum, oilPressure.maximum,

172
00:08:57,610 --> 00:09:04,680
oilPressure.value. Được rồi, vậy về cơ bản tôi

173
00:09:04,680 --> 00:09:09,220
đang sử dụng một cách lấy những thứ mà tôi

174
00:09:09,220 --> 00:09:12,670
gán trong C++. Tôi điều khiển vòng đời

175
00:09:12,670 --> 00:09:15,550
của chúng và đẩy chúng vào

176
00:09:15,550 --> 00:09:18,100
engine thực thi của QML. Có một nguyên tắc duy nhất là

177
00:09:18,100 --> 00:09:20,590
trong thời gian tồn tại của view, những

178
00:09:20,590 --> 00:09:23,110
đối tượng này cần phải tồn tại hoặc bạn sẽ

179
00:09:23,110 --> 00:09:28,680
bị lỗi seg fault. Điều này hợp lý phải không?

180
00:09:31,110 --> 00:09:35,800
Đó là một cách nhanh và tạm về

181
00:09:35,800 --> 00:09:39,370
việc lấy. Và thậm chí là thích hợp trong một số

182
00:09:39,370 --> 00:09:41,200
trường hợp mà bạn đang lấy dữ liệu.

183
00:09:41,200 --> 00:09:43,510
Đặc biệt là những mô hình dữ liệu mà bạn có trong

184
00:09:43,510 --> 00:09:46,090
C++. Và bạn sẽ chỉ export chúng

185
00:09:46,090 --> 00:09:49,330
vào môi trường hoạt động của QML (QML runtime environment).

186
00:09:49,330 --> 00:09:51,520
Có thể đó là dữ liệu theo dạng bảng mà

187
00:09:51,520 --> 00:09:53,500
bạn có, và nó sẽ hiển thị như một biểu đồ hình bánh

188
00:09:53,500 --> 00:09:55,810
Hay thứ gì đó mà ta đang đọc từ

189
00:09:55,810 --> 00:10:03,610
một cổng serial port hay từ mạng.

190
00:10:03,610 --> 00:10:06,090
Có ai hỏi gì không?

191
00:10:07,830 --> 00:10:10,230
Vậy ta sẽ quay lại phần bài giảng mà

192
00:10:10,230 --> 00:10:12,390
mặc dù tôi cũng đã nói về nó. Đó là

193
00:10:12,390 --> 00:10:15,300
cách export các kiểu (type). Thay vì

194
00:10:15,300 --> 00:10:18,959
ta có những instance mà ta đẩy vài QML,

195
00:10:18,959 --> 00:10:21,060
thì tôi muốn nói là tôi sẽ tạo ra kiểu của riêng tôi,

196
00:10:21,060 --> 00:10:24,300
có thể lấy tên là car. Và chúng ta sẽ

197
00:10:24,300 --> 00:10:27,089
để các lập trình viên QML tạo ra một instance của

198
00:10:27,089 --> 00:10:31,940
car, trong đó việc lập trình của car là trong C++.

199
00:10:31,940 --> 00:10:34,200
Chúng ta sẽ thực hiện điều đó, và chúng ta sẽ

200
00:10:34,200 --> 00:10:35,579
thực sự thực hiện điều đó với một item có hình ellipse (ellipse item).

201
00:10:35,579 --> 00:10:38,070
Tôi đã nói rằng không có ellipse item

202
00:10:38,070 --> 00:10:43,649
hay item có hình tròn (circle item) trong QML.
Nhưng chúng ta có thể tạo ra

203
00:10:43,649 --> 00:10:45,990
cho riêng chúng ta và ta có thể vẽ và

204
00:10:45,990 --> 00:10:48,980
quản lý nó trong C++.

205
00:10:50,450 --> 00:10:55,380
Vậy bất cứ lúc nào bạn muốn viết code C++,

206
00:10:55,380 --> 00:10:58,050
thì nó sẽ biết về

207
00:10:58,050 --> 00:11:00,630
môi trường khai báo. Có một

208
00:11:00,630 --> 00:11:02,850
module Qt tên là

209
00:11:02,850 --> 00:11:05,519
QtDeclarative. Trong tập tin dự án (project file) của bạn, bạn

210
00:11:05,519 --> 00:11:06,930
cần phải có QT += declarative.

211
00:11:06,930 --> 00:11:08,700
Và bạn cần phải

212
00:11:08,700 --> 00:11:11,310
bao gồm (include) những thứ từ module QtDeclarative.

213
00:11:11,310 --> 00:11:14,100
Thường thì có một vài

214
00:11:14,100 --> 00:11:16,529
header file mà bạn có thể sử dụng

215
00:11:16,529 --> 00:11:18,480
để include QtDeclarative và lấy

216
00:11:18,480 --> 00:11:23,820
chúng. Đây là một ví dụ, trong đó tôi

217
00:11:23,820 --> 00:11:26,810
include QDeclarativeView. Và

218
00:11:26,810 --> 00:11:29,880
như trong ví dụ mà ta đã thấy, tôi tạo ra

219
00:11:29,880 --> 00:11:31,920
một Declarative View, và tôi setSource

220
00:11:31,920 --> 00:11:36,510
vào đó. Tôi show ra cửa sổ màn hình và tôi exec

221
00:11:36,510 --> 00:11:38,760
từng view mà bạn tạo ra là một

222
00:11:38,760 --> 00:11:41,339
môi trường hoạt động (runtime environment)
mới. Nên có thể bạn sẽ muốn

223
00:11:41,339 --> 00:11:44,630
thực hiện càng ít cái này càng tốt.

224
00:11:47,360 --> 00:11:50,100
Trong tập tin dự án của bạn thì bạn sẽ muốn

225
00:11:50,100 --> 00:11:53,579
sử dụng QT += declarative. Bây giờ,

226
00:11:53,579 --> 00:11:57,240
từ khi nó trở thành RESOURCES, thì QML của bạn

227
00:11:57,240 --> 00:11:59,699
có thể được lưu trữ thực sự trong QT

228
00:11:59,699 --> 00:12:05,970
RESOURCES. Vậy nên khi bạn gọi trong

229
00:12:05,970 --> 00:12:10,949
setSource ở đây là "qrc:files/animation.qml",

230
00:12:10,949 --> 00:12:13,140
thì cái này đến từ RESOURCES.

231
00:12:13,140 --> 00:12:16,680
Và hãy nhớ rằng mọi thứ là có liên quan

232
00:12:16,680 --> 00:12:20,010
tới vị trí của tập tin qml mà bạn

233
00:12:20,010 --> 00:12:20,950
đang chạy.

234
00:12:20,950 --> 00:12:23,800
Nội dung của file/animation

235
00:12:23,800 --> 00:12:25,600
là QML sẽ sử dụng mọi

236
00:12:25,600 --> 00:12:28,649
biện pháp. Và file đó sẽ có liên quan

237
00:12:28,649 --> 00:12:32,290
đến resource file. Nên bạn sẽ

238
00:12:32,290 --> 00:12:35,380
phải include toàn bộ mã nguồn QML (QML source code)

239
00:12:35,380 --> 00:12:37,269
vào resource thì bạn có thể

240
00:12:37,269 --> 00:12:39,639
phân bổ phần thực thi và không

241
00:12:39,639 --> 00:12:41,350
phải lo về toàn bộ

242
00:12:41,350 --> 00:12:43,630
tập tin QML để phân bổ cùng với

243
00:12:43,630 --> 00:12:48,389
phần thực thi.

244
00:12:56,600 --> 00:12:58,850
Vâng, điều đó là đúng. Có một

245
00:12:58,850 --> 00:13:01,939
cách để phá nguyên tắc cho main.qml.

246
00:13:01,939 --> 00:13:05,540
Root item, bạn có thể gọi tên nó như vậy, không

247
00:13:05,540 --> 00:13:08,290
cần bắt đầu bằng một chữ in hoa.

248
00:13:08,290 --> 00:13:11,869
Và đôi khi bạn sẽ thấy có nhiều

249
00:13:11,869 --> 00:13:13,519
dự án chỉ bắt đầu bằng

250
00:13:13,519 --> 00:13:16,429
main.qml, mà có chữ đầu tiên là một

251
00:13:16,429 --> 00:13:21,679
chữ m in thường. Nhưng với tất cả những tập tin khác mà

252
00:13:21,679 --> 00:13:24,289
cần được load (tải / nạp) bằng QML, thì chúng cần

253
00:13:24,289 --> 00:13:27,279
bắt đầu bằng chữ in hoa.

254
00:13:37,480 --> 00:13:42,190
Vậy để tạo ra một instance mới cho kiểu của bạn,

255
00:13:42,190 --> 00:13:47,350
bạn có thể thừa kế trực tiếp từ

256
00:13:47,350 --> 00:13:50,590
QObject, hoặc bạn có thể sử dụng QDeclarativeItem.

257
00:13:50,590 --> 00:13:55,720
Nếu bạn muốn vẽ trên

258
00:13:55,720 --> 00:13:58,720
màn hình, thì bạn cần sử dụng QDeclarativeItem

259
00:13:58,720 --> 00:14:01,690
mà trực tiếp trùng khớp khá nhiều với

260
00:14:01,690 --> 00:14:07,090
Item trong QML. Nếu bạn chỉ muốn

261
00:14:07,090 --> 00:14:09,310
dữ liệu mà là

262
00:14:09,310 --> 00:14:12,100
instance và duyệt qua, thì bạn có thể

263
00:14:12,100 --> 00:14:14,110
chỉ cần thừa kế thẳng từ QObject,

264
00:14:14,110 --> 00:14:19,540
và bỏ qua phần overhead. Vậy,

265
00:14:19,540 --> 00:14:21,130
về cơ bản thì điều đang diễn ra là

266
00:14:21,130 --> 00:14:24,100
bạn sẽ đăng ký kiểu này là

267
00:14:24,100 --> 00:14:26,950
hợp lệ (valid) trong QML, rồi ta sẽ hiểu

268
00:14:26,950 --> 00:14:31,750
ý nghĩa của việc đó sau một lúc nữa. Hãy xem ví dụ.

269
00:14:31,750 --> 00:14:37,360
Đầu tiên là tập tin ellipse1.qml này hiện nay

270
00:14:37,360 --> 00:14:39,670
chưa có ellipse item trong QML. Chúng ta

271
00:14:39,670 --> 00:14:42,490
sẽ thực hiện việc đó trong C++ và để người dùng

272
00:14:42,490 --> 00:14:45,900
sử dụng nó. Ở đây ta có import Shapes 1.0.

273
00:14:45,900 --> 00:14:48,670
Ta có module mới này tên là

274
00:14:48,670 --> 00:14:51,280
Shapes, và bên trong Shapes

275
00:14:51,280 --> 00:14:54,430
là ellipse item mà ta tạo ra nó

276
00:14:54,430 --> 00:14:58,840
giống như những item QML khác. Từ

277
00:14:58,840 --> 00:15:02,500
góc nhìn của tập tin này thì người dùng

278
00:15:02,500 --> 00:15:05,350
không biết ellipse là tập tin QML

279
00:15:05,350 --> 00:15:07,960
hay là một trong những plugin của C++.

280
00:15:07,960 --> 00:15:12,550
Còn từ quan điểm của API thì rất rõ.

281
00:15:12,550 --> 00:15:17,290
Và Ellipse sẽ

282
00:15:17,290 --> 00:15:19,420
vẽ ra một hình ellipse nhỏ ở bên phải.

283
00:15:19,420 --> 00:15:24,220
Nó khá là đơn giản. Cách để ta tạo ra

284
00:15:24,220 --> 00:15:26,560
item có width và height,

285
00:15:26,560 --> 00:15:29,980
và vẽ được trong QML là chúng ta chỉ việc

286
00:15:29,980 --> 00:15:33,400
include QDeclarativeItem và kế thừa

287
00:15:33,400 --> 00:15:36,730
từ nó. Chúng ta sử dụng Q_OBJECT là macro

288
00:15:36,730 --> 00:15:40,650
được yêu cầu phải có rồi ta

289
00:15:40,650 --> 00:15:43,780
thực hiện hàm tạo nhận con trỏ

290
00:15:43,780 --> 00:15:46,840
QDeclarativeItem *parent. Cái này

291
00:15:46,840 --> 00:15:49,990
sẽ được QML sử dụng để gán

292
00:15:49,990 --> 00:15:50,950
parent

293
00:15:50,950 --> 00:15:54,310
giống như bạn thực hiện cho Q_OBJECT và QWidget.

294
00:15:54,310 --> 00:15:56,170
Đây là phân cấp cha-con

295
00:15:56,170 --> 00:15:59,920
mà chúng ta đã sử dụng. Sau đó

296
00:15:59,920 --> 00:16:03,570
bạn cần thực hiện hàm paint.

297
00:16:03,570 --> 00:16:07,270
Hàm này là ánh xạ 1:1 và

298
00:16:07,270 --> 00:16:09,580
ở trên QDeclarativeItem

299
00:16:09,580 --> 00:16:13,980
kế thừa QGraphicsItem. Và

300
00:16:13,980 --> 00:16:17,140
QGraphicsItem có hàm (method) paint

301
00:16:17,140 --> 00:16:19,750
nhận con trỏ painter,

302
00:16:19,750 --> 00:16:22,000
QStyleOptionGraphicsItem, và con trỏ widget

303
00:16:22,000 --> 00:16:23,770
mà là widget bạn đang

304
00:16:23,770 --> 00:16:30,790
vẽ. Vậy việc thực hiện

305
00:16:30,790 --> 00:16:33,010
thật sự khá dễ, ta có một hàm tạo

306
00:16:33,010 --> 00:16:35,230
đơn giản, ta duyệt parent vào

307
00:16:35,230 --> 00:16:38,710
superclass, và ta cần có hàm

308
00:16:38,710 --> 00:16:43,030
setFlag này. Về mặc định thì các item chưa được vẽ.

309
00:16:43,030 --> 00:16:45,280
Nếu bạn muốn vẽ trên màn hình,

310
00:16:45,280 --> 00:16:47,680
thì bạn cần setFlag cho QGraphicsItem::

311
00:16:47,680 --> 00:16:52,780
ItemHasNoContents thành false. Tại sao

312
00:16:52,780 --> 00:16:54,670
về mặc định thì nó không vẽ trên

313
00:16:54,670 --> 00:16:57,040
màn hình thì tôi không chắc, nhưng đó là điều mà bạn

314
00:16:57,040 --> 00:17:02,860
phải thực hiện trong hàm paint của nó. Chúng ta làm

315
00:17:02,860 --> 00:17:06,490
một việc siêu cơ bản. Chúng ta lấy

316
00:17:06,490 --> 00:17:08,170
con trỏ QPainter mà ta đã duyệt.

317
00:17:08,170 --> 00:17:10,420
Và painter như bạn biết từ

318
00:17:10,420 --> 00:17:14,109
API trong C++ có một hàm drawEllipse

319
00:17:14,109 --> 00:17:16,750
mà nhận vào một hình chữ nhật. Và chúng ta

320
00:17:16,750 --> 00:17:19,060
sẽ nhận option->rect mà được

321
00:17:19,060 --> 00:17:21,339
xác định là hình dạng chữ nhật của màn hình

322
00:17:21,339 --> 00:17:26,020
mà ta tiếp nhận. Vậy, cho dù có bao nhiêu không gian mà ta

323
00:17:26,020 --> 00:17:27,790
được cấp thì ta sẽ cố gắng

324
00:17:27,790 --> 00:17:30,270
vẽ một hình ellipse mà sẽ

325
00:17:30,270 --> 00:17:34,350
nằm trong hình chữ nhật đó.

326
00:17:41,750 --> 00:17:44,460
Bạn có thể tưởng tượng nếu bạn là một

327
00:17:44,460 --> 00:17:47,190
root item thì có thể ai đó bắt đầu một tập tin QML

328
00:17:47,190 --> 00:17:50,550
có hàm ellipse( nhưng bạn

329
00:17:50,550 --> 00:18:02,400
không có parent. Bây giờ parent của bạn là

330
00:18:02,400 --> 00:18:05,340
một QDeclarativeItem khác. Widget

331
00:18:05,340 --> 00:18:08,760
mà bạn đã duyệt vào hàm paint

332
00:18:08,760 --> 00:18:11,640
là khá vô dụng. Nhưng thực tế là nó ở đó

333
00:18:11,640 --> 00:18:13,260
bởi vì nó hữu dụng khi bạn đang

334
00:18:13,260 --> 00:18:15,030
lập trình đồ họa cho Qt, và

335
00:18:15,030 --> 00:18:17,280
bạn đang kế thừa từ QGraphicsView ở đây.

336
00:18:17,280 --> 00:18:21,120
Đây là một khai báo chuyển tiếp (forward declaration) trong

337
00:18:21,120 --> 00:18:24,890
QML 2.0. Hàm API này đang thay đổi.

338
00:18:24,890 --> 00:18:29,730
Nhưng nếu bạn sử dụng QDeclarativeItem thì bạn

339
00:18:29,730 --> 00:18:32,970
thật sự có thể nhận được

340
00:18:32,970 --> 00:18:37,460
tên và cú pháp của hàm giống như vậy bằng cách sử dụng

341
00:18:37,460 --> 00:18:41,400
item vẽ nhanh trong Qt. Như vậy có một

342
00:18:41,400 --> 00:18:43,920
cách cập nhật, nhưng sẽ không còn

343
00:18:43,920 --> 00:18:49,110
QDeclarativeItem nữa. Và điều đó sẽ

344
00:18:49,110 --> 00:18:58,200
thay đổi trong Qt 5. Vâng, điều ta có

345
00:18:58,200 --> 00:19:01,890
trong hàm main là thay vì export một

346
00:19:01,890 --> 00:19:03,630
instance C++ của thứ gì đó, thì thực tế là ta

347
00:19:03,630 --> 00:19:07,260
đang sử dụng hàm macro qmlRegisterType này

348
00:19:07,260 --> 00:19:12,000
để đăng ký cho một kiểu vào QML

349
00:19:12,000 --> 00:19:16,650
runtime. Rồi ta export

350
00:19:16,650 --> 00:19:20,610
class EllipseItem và đặt nó vào

351
00:19:20,610 --> 00:19:24,990
"Shapes" module, major version là 1, minor

352
00:19:24,990 --> 00:19:28,680
version là 0, và tên của item này

353
00:19:28,680 --> 00:19:31,530
sẽ là "Ellipse". Hãy lưu ý rằng

354
00:19:31,530 --> 00:19:35,640
tên không phải trùng khớp. Sau đó chúng ta

355
00:19:35,640 --> 00:19:38,460
tiếp tục và thực hiện view. Chúng ta

356
00:19:38,460 --> 00:19:42,710
setSource, và bây giờ đoạn code sử dụng

357
00:19:42,710 --> 00:19:46,200
EllipseItem sẽ hoạt động.

358
00:19:46,200 --> 00:19:49,380
Bởi vì bây giờ Ellipse là một kiểu hợp lệ. Khi

359
00:19:49,380 --> 00:19:51,390
bạn tạo ra một instance của Ellipse, thì

360
00:19:51,390 --> 00:19:52,740
thật ra là sẽ tạo một instance của

361
00:19:52,740 --> 00:19:55,430
EllipseItem.

362
00:20:05,450 --> 00:20:09,250
Đó là cái hay của nó.

363
00:20:12,710 --> 00:20:16,130
Về cơ bản, do bạn

364
00:20:16,130 --> 00:20:17,900
thừa kế QDeclarativeItem,

365
00:20:17,900 --> 00:20:21,290
nên bạn đang thừa kế item. Hãy nhớ rằng

366
00:20:21,290 --> 00:20:23,750
item là phần chung trong lớp cơ bản (base class)

367
00:20:23,750 --> 00:20:25,400
của mọi thứ mà về cơ bản là điều

368
00:20:25,400 --> 00:20:27,560
mà bạn đang thừa kế. Cho nên bạn có x, y,

369
00:20:27,560 --> 00:20:30,410
độ trong suốt, độ mờ cùng mọi

370
00:20:30,410 --> 00:20:33,200
thuộc tính của item mà bạn thừa kế, giống như

371
00:20:33,200 --> 00:20:34,970
khi bạn thừa kế từ C++, từ

372
00:20:34,970 --> 00:20:36,980
Q_OBJECT có các thuộc tính,
thì bạn cũng thừa kế mọi

373
00:20:36,980 --> 00:20:41,000
thuộc tính của chúng. Vậy từ góc nhìn

374
00:20:41,000 --> 00:20:42,500
của phía client thì cho dù ai thực hiện

375
00:20:42,500 --> 00:20:44,900
hay đang viết đoạn QML đó sẽ không bao giờ

376
00:20:44,900 --> 00:20:47,000
biết cái gì được thực hiện trong C++, và

377
00:20:47,000 --> 00:20:49,730
cái gì được thực hiện trong QML. Đó là một

378
00:20:49,730 --> 00:20:53,540
điều tốt. Nó không có gì khác biệt.

379
00:20:53,540 --> 00:20:56,750
Nếu bạn viết một đoạn QML và bạn

380
00:20:56,750 --> 00:21:00,140
có đối tượng board game màu mè này. Rồi bạn

381
00:21:00,140 --> 00:21:01,760
phát hiện rằng nó không đủ nhanh để hoạt động

382
00:21:01,760 --> 00:21:03,710
trong JavaScript. Chà! Bạn có thể tạo ra

383
00:21:03,710 --> 00:21:06,230
board game trong C++ rồi export nó thành

384
00:21:06,230 --> 00:21:08,120
board game. Và phần code trong board game của bạn

385
00:21:08,120 --> 00:21:18,490
vẫn sẽ hoạt động. Vậy, hãy lưu ý ở đây là chúng ta

386
00:21:18,490 --> 00:21:20,330
đang đăng ký những đối tượng này với

387
00:21:20,330 --> 00:21:22,760
các import có đầy đủ thuộc tính. Vậy, cái này import

388
00:21:22,760 --> 00:21:25,520
Shapes, 1, 0. Không có cách nào thực hiện việc này

389
00:21:25,520 --> 00:21:27,590
mà không có module và

390
00:21:27,590 --> 00:21:29,980
số phiên bản (version).

391
00:21:36,410 --> 00:21:39,050
Và kết quả là kiểu con (sub type) của

392
00:21:39,050 --> 00:21:43,220
item. Ở đây là ví dụ tôi có về

393
00:21:43,220 --> 00:21:45,980
ellipse item, và tôi muốn thêm vào một

394
00:21:45,980 --> 00:21:48,380
thuộc tính. Tôi muốn thêm một thuộc tính vào

395
00:21:48,380 --> 00:21:51,530
ellipse để cho nó có màu sắc. Tôi muốn

396
00:21:51,530 --> 00:21:54,860
tô hình Ellipse ở đây bằng màu xanh da trời (color: "blue").

397
00:21:54,860 --> 00:21:56,900
Ta dễ dàng có được x, x, width và height

398
00:21:56,900 --> 00:21:59,630
từ việc thừa kế item, nhưng ta cần thêm

399
00:21:59,630 --> 00:22:02,080
màu (color) vào.

400
00:22:02,170 --> 00:22:06,200
May mắn là việc thêm color cũng đơn giản như

401
00:22:06,200 --> 00:22:09,290
thêm macro Q_PROPERTY. Ta cần

402
00:22:09,290 --> 00:22:12,260
một hàm read và một hàm write cùng một

403
00:22:12,260 --> 00:22:18,650
notify signal. Như vậy bạn sẽ thực hiện đoạn C++

404
00:22:18,650 --> 00:22:21,740
như thường lệ. Có nghĩa là bạn sẽ có

405
00:22:21,740 --> 00:22:23,600
một member cho color. Bạn sẽ

406
00:22:23,600 --> 00:22:27,340
có setColor, color getter. Và

407
00:22:27,340 --> 00:22:29,570
bạn sẽ có một signal cho colorChanged.

408
00:22:29,570 --> 00:22:32,720
Đây là một điều bình thường với Qt mà bạn

409
00:22:32,720 --> 00:22:36,080
có thể có. Sau đó, trong header file, bạn

410
00:22:36,080 --> 00:22:38,360
chỉ việc sử dụng macro Q_PROPERTY. Bạn

411
00:22:38,360 --> 00:22:40,250
xác định kiểu của property này

412
00:22:40,250 --> 00:22:43,580
là QColor, và trong tên thì chỉ việc có từ khóa color.

413
00:22:43,580 --> 00:22:46,700
Hàm đọc (read) tên là color, hàm ghi (write)

414
00:22:46,700 --> 00:22:49,070
tên là setColor và notify signal

415
00:22:49,070 --> 00:22:54,400
tên là colorChanged. Đây là một

416
00:22:54,400 --> 00:22:57,290
tính chất mà bạn không có trong

417
00:22:57,290 --> 00:22:59,210
QML, là bạn có thể tạo ra

418
00:22:59,210 --> 00:23:02,900
những thuộc tính chỉ đọc bằng cách điều khiển

419
00:23:02,900 --> 00:23:05,600
macro Q_PROPERTY. Cho nên nếu bạn không

420
00:23:05,600 --> 00:23:08,960
có hàm ghi thì bạn sẽ tạo ra

421
00:23:08,960 --> 00:23:11,300
thuộc tính chỉ đọc. Và nếu ai đó cố thiết lập

422
00:23:11,300 --> 00:23:13,970
giá trị trong QML runtime thì sẽ

423
00:23:13,970 --> 00:23:16,250
phàn nàn và nói rằng

424
00:23:16,250 --> 00:23:20,780
đó là một thuộc tính chỉ đọc. Đồng thời, vài

425
00:23:20,780 --> 00:23:24,290
thuộc tính không có sự linh hoạt. Vậy nên

426
00:23:24,290 --> 00:23:27,940
không có lý do gì để có thông báo (notification signal).

427
00:23:27,940 --> 00:23:30,800
Trong trường hợp đó, bạn có thể thay

428
00:23:30,800 --> 00:23:34,370
NOTIFY bằng const. Và bạn không cần

429
00:23:34,370 --> 00:23:37,250
chỉ định một signal để báo cho môi trường QML

430
00:23:37,250 --> 00:23:39,560
là không bao giờ phải chờ signal

431
00:23:39,560 --> 00:23:42,560
khi những thay đổi này thường xuyên diễn ra, hay khi bạn

432
00:23:42,560 --> 00:23:45,230
muốn có các hằng số chỉ đọc (read-only constant)

433
00:23:45,230 --> 00:23:48,040
được coi như các thuộc tính.

434
00:23:54,580 --> 00:24:00,769
Vậy, khá là đơn giản khi bạn ở trong C++.

435
00:24:00,769 --> 00:24:02,419
Ví dụ, nếu bạn đang viết graphicsItem

436
00:24:02,419 --> 00:24:04,879
thì bạn có đang viết các widget trong những

437
00:24:04,879 --> 00:24:07,639
hàm set của bạn hay không? Bạn nên luôn luôn đảm bảo rằng

438
00:24:07,639 --> 00:24:09,259
thứ mà bạn đang set là khác với

439
00:24:09,259 --> 00:24:10,789
thứ mà bạn đã set chưa. Điều đó sẽ giữ

440
00:24:10,789 --> 00:24:13,159
bạn khỏi việc gặp phải đệ quy vô hạn. Nếu

441
00:24:13,159 --> 00:24:15,559
bạn có các signal và slot,

442
00:24:15,559 --> 00:24:19,759
và bạn setColor. Bạn gọi update

443
00:24:19,759 --> 00:24:23,299
để đổi màu rồi bạn phát ra (emit)

444
00:24:23,299 --> 00:24:25,460
signal đúng rồi ở đây ta có

445
00:24:25,460 --> 00:24:30,859
signal colorChanged. Còn bây giờ, toàn bộ

446
00:24:30,859 --> 00:24:37,669
đoạn code này về cơ bản cũng coi như thuộc tính color

447
00:24:37,669 --> 00:24:40,850
trong QML vì nó là

448
00:24:40,850 --> 00:24:42,649
một thuộc tính thật. Có một

449
00:24:42,649 --> 00:24:45,259
đoạn xử lý (handler) signal colorChanged mà bạn có thể

450
00:24:45,259 --> 00:24:47,470
thực hiện.

451
00:25:00,670 --> 00:25:03,970
Đó là một câu hỏi hay. Tôi đoán là không có lý do

452
00:25:03,970 --> 00:25:05,470
cụ thể nào mà nó có thể gọi được

453
00:25:05,470 --> 00:25:10,840
ellipse. Câu hỏi hay!

454
00:25:10,840 --> 00:25:14,680
Vậy hàm main khi ta export thì nó thực hiện

455
00:25:14,680 --> 00:25:17,830
qmlRegisterType này và nó nhận vào

456
00:25:17,830 --> 00:25:22,930
một xâu kí tự của tên để sử dụng cho tên kiểu. Nó

457
00:25:22,930 --> 00:25:24,820
không bắt buộc phải giống như

458
00:25:24,820 --> 00:25:34,480
tên class. Đó là? Nó là một mẫu (template).

459
00:25:34,480 --> 00:25:38,920
Nó là một template. Bây giờ, điều hay

460
00:25:38,920 --> 00:25:41,670
về Qt nói chung là Qt sử dụng

461
00:25:41,670 --> 00:25:44,110
các template. Bạn biết đấy, ở chỗ này, chỗ đó, và ở mọi

462
00:25:44,110 --> 00:25:46,060
chỗ. Nhưng nó có thật sự bắt

463
00:25:46,060 --> 00:25:48,340
bạn viết các class template mặc dù là

464
00:25:48,340 --> 00:25:51,040
tốt không? Đây là ví dụ về một

465
00:25:51,040 --> 00:25:54,070
hàm template. Nó nhận vào một kiểu rồi

466
00:25:54,070 --> 00:25:56,640
thực hiện điều kì diệu của nó.

467
00:26:03,230 --> 00:26:06,500
Sau đó nó sẽ được gọi

468
00:26:06,500 --> 00:26:08,210
trong method paint giống như trong

469
00:26:08,210 --> 00:26:10,399
các widget hay trong graphic, nó sẽ được

470
00:26:10,399 --> 00:26:13,220
gọi vào lúc bạn gọi update. Giờ thì nó

471
00:26:13,220 --> 00:26:14,630
trở nên phức tạp hơn chút do

472
00:26:14,630 --> 00:26:17,389
chúng ta không thể chỉ việc vẽ hình ellipse mà ta

473
00:26:17,389 --> 00:26:19,279
sẽ lưu lại (save) trạng thái của painter. Chúng ta

474
00:26:19,279 --> 00:26:21,649
sẽ setPen, setBrush,

475
00:26:21,649 --> 00:26:23,480
drawEllipse,

476
00:26:23,480 --> 00:26:28,190
rồi khôi phục (restore) trạng thái của painter.

477
00:26:28,190 --> 00:26:30,380
Việc lưu rồi khôi phục

478
00:26:30,380 --> 00:26:33,139
các trạng thái của painter vào lúc ai đó duyệt

479
00:26:33,139 --> 00:26:37,880
con trỏ QPainter là phù hợp. Sẽ không

480
00:26:37,880 --> 00:26:39,980
hợp lý nếu bạn thay đổi nội dung

481
00:26:39,980 --> 00:26:42,139
con trỏ của ai đó khi hàm của bạn

482
00:26:42,139 --> 00:26:50,809
trả về. Tổng kết lại thì ta đã

483
00:26:50,809 --> 00:26:53,600
thấy rằng ta có thể tạo một kiểu mới với

484
00:26:53,600 --> 00:26:56,389
qmlRegisterType, ta có thể tạo ra một

485
00:26:56,389 --> 00:26:59,090
item mới với QDeclarativeItem,

486
00:26:59,090 --> 00:27:04,880
và ta có thể thêm vào vài thuộc tính của Qt.

487
00:27:04,880 --> 00:27:06,919
Có ai có câu hỏi nào về phần này không?

488
00:27:06,919 --> 00:27:08,840
Chúng ta sẽ chuyển sang các hàm,

489
00:27:08,840 --> 00:27:17,690
slot cùng những thứ hay ho như enum. Vâng?

490
00:27:17,690 --> 00:27:19,669
Thực tế là bạn có thể có một tham số mà phần lớn

491
00:27:19,669 --> 00:27:21,889
thời gian là trong C++. Bạn sẽ có một

492
00:27:21,889 --> 00:27:28,159
tham số là newColor. QML sẽ

493
00:27:28,159 --> 00:27:31,130
luôn lờ đi tham số. Đó là

494
00:27:31,130 --> 00:27:32,510
một trong những đặc điểm của Qt. Bạn luôn có thể

495
00:27:32,510 --> 00:27:36,169
bỏ những tham số từ signal cho tới slot.

496
00:27:36,169 --> 00:27:41,630
Khi signal. Khi

497
00:27:41,630 --> 00:27:43,610
thuộc tính thay đổi thì nó sẽ là một

498
00:27:43,610 --> 00:27:46,460
signal không có tham số. Nó chỉ muốn

499
00:27:46,460 --> 00:27:48,250
biết kiểu cần phải trả về của tất cả

500
00:27:48,250 --> 00:27:51,250
biểu thức.

501
00:28:01,340 --> 00:28:07,129
Ồ. Không. Nhưng đó là điều bạn có thể làm và bạn biết

502
00:28:07,129 --> 00:28:11,419
việc này. Việc này sẽ giúp bạn

503
00:28:11,419 --> 00:28:13,549
là bạn có thể kế thừa từ

504
00:28:13,549 --> 00:28:16,730
QDeclarativeItem. Được rồi, và bạn

505
00:28:16,730 --> 00:28:19,460
thật sự có thể thừa kế từ

506
00:28:19,460 --> 00:28:23,749
widget QProxy rồi bạn có thể bọc

507
00:28:23,749 --> 00:28:27,499
widget của Qt vào các widget QProxy,

508
00:28:27,499 --> 00:28:33,019
mà là một QGraphicsItem.

509
00:28:33,019 --> 00:28:36,700
Bạn có thể tìm những ví dụ trên mạng về điều đó.

510
00:28:36,700 --> 00:28:38,269
Hãy chú ý.

511
00:28:38,269 --> 00:28:39,950
Giống như khi lập trình graphic view

512
00:28:39,950 --> 00:28:42,320
thì widget QProxy có

513
00:28:42,320 --> 00:28:44,869
vấn đề về hiệu năng. Cho nên nếu bạn cố gắng

514
00:28:44,869 --> 00:28:47,539
lấy màn hình QML mà có

515
00:28:47,539 --> 00:28:50,360
Q table được nhúng trong đó. Rồi bạn cố gắng

516
00:28:50,360 --> 00:28:52,970
tạo hiệu ứng thì có khả năng nó sẽ bị giảm

517
00:28:52,970 --> 00:28:56,889
hiệu năng. Nhưng bạn có thể làm việc đó.

518
00:28:56,889 --> 00:29:00,350
Thực tế, chúng ta đã thực hiện việc đó tại ICS trong

519
00:29:00,350 --> 00:29:03,289
một số dự án mà sử dụng biểu đồ QWT (QWT chart) để

520
00:29:03,289 --> 00:29:12,070
thực hiện một số hiệu ứng. Vâng.

521
00:29:15,270 --> 00:29:27,280
Vâng. Tốt hơn là sử dụng nhiều signal.

522
00:29:27,280 --> 00:29:29,260
Bởi vì trừ khi chúng liên quan đến nhau

523
00:29:29,260 --> 00:29:32,770
về bản chất. Bởi vì khi

524
00:29:32,770 --> 00:29:35,710
signal đó kích hoạt thì QML sẽ trả về mọi

525
00:29:35,710 --> 00:29:40,030
liên kết mà có bao gồm thuộc tính đó. Vậy nên

526
00:29:40,030 --> 00:29:42,070
nếu bạn thay đổi một thuộc tính, nhưng bạn chỉ

527
00:29:42,070 --> 00:29:44,860
có signal thay đổi mọi thứ này,

528
00:29:44,860 --> 00:29:46,450
mà gắn với bốn thuộc tính khác nhau,

529
00:29:46,450 --> 00:29:48,850
thì QML sẽ tìm ra

530
00:29:48,850 --> 00:29:51,460
bốn thuộc tính đó rồi trả về kết quả của mọi

531
00:29:51,460 --> 00:29:53,950
biểu thức trong mối liên kết. Trái ngược

532
00:29:53,950 --> 00:29:55,570
với việc có một thuộc tính thay đổi thì bạn có thể

533
00:29:55,570 --> 00:29:57,970
chỉ có 2 dòng lệnh,

534
00:29:57,970 --> 00:30:00,520
thay vì 20 dòng sẽ được

535
00:30:00,520 --> 00:30:03,040
tính lại. Đó là nội dung trong

536
00:30:03,040 --> 00:30:05,460
phần đó.

537
00:30:16,090 --> 00:30:20,149
Bây giờ, tôi muốn thêm các hàm. Ồ,

538
00:30:20,149 --> 00:30:23,200
thật ra là tôi muốn thêm các signal vào

539
00:30:23,200 --> 00:30:28,370
class trong Qt mà ta đang export vào QML.

540
00:30:28,370 --> 00:30:30,140
Về cơ bản, điều ta muốn

541
00:30:30,140 --> 00:30:32,059
sẽ không có ellipse,

542
00:30:32,059 --> 00:30:35,149
mà là một signal onReady. Rồi ta có thể sử dụng

543
00:30:35,149 --> 00:30:39,409
onReady signal handler. Ready trong

544
00:30:39,409 --> 00:30:41,480
trường hợp này không thật sự có nghĩa gì.

545
00:30:41,480 --> 00:30:44,750
Nó không giống QML và Qt

546
00:30:44,750 --> 00:30:46,340
chạy trong các luồng (thread) riêng biệt rồi

547
00:30:46,340 --> 00:30:47,899
có một vài sự đồng bộ mà cần thực hiện.

548
00:30:47,899 --> 00:30:50,659
Đây chỉ là một ví dụ, chỉ là

549
00:30:50,659 --> 00:30:54,260
trạng thái nào đó đang thay đổi. Điều tôi

550
00:30:54,260 --> 00:30:57,830
muốn thực hiện khi cái gì đó sẵn sàng là tôi

551
00:30:57,830 --> 00:31:00,139
muốn thay đổi label text nào đó để báo

552
00:31:00,139 --> 00:31:06,590
Ready. Rất đơn giản. Và điều bạn cần làm

553
00:31:06,590 --> 00:31:10,970
trong Qt là thực hiện điều
bạn sẽ làm như thông thường,

554
00:31:10,970 --> 00:31:13,909
Chỉ việc khai báo một signal Ready
giống như bạn đã thực hiện

555
00:31:13,909 --> 00:31:16,880
trong phần đổi màu. Những
đối tượng biến đổi (meta-object) sẽ lấy

556
00:31:16,880 --> 00:31:18,590
mọi thứ từ đó. Bạn chỉ việc biên dịch lại

557
00:31:18,590 --> 00:31:21,289
chương trình và tất nhiên là bạn cần

558
00:31:21,289 --> 00:31:25,610
emit signal. Nhưng sau khi bạn thực hiện

559
00:31:25,610 --> 00:31:30,799
signal thì đoạn code này sẽ chạy cứ khi nào

560
00:31:30,799 --> 00:31:38,649
emit của bạn là ready. Ví dụ ta có một

561
00:31:38,649 --> 00:31:42,080
signal QTimer single-shot

562
00:31:42,080 --> 00:31:45,220
để sau 2 giây thì ta sẽ

563
00:31:45,220 --> 00:31:49,909
phát ra signal ready. Cho nên tại thời điểm nào đó

564
00:31:49,909 --> 00:31:52,070
thì signal sẽ được phát ra,

565
00:31:52,070 --> 00:31:54,830
onReady sẽ được gọi rồi ta có

566
00:31:54,830 --> 00:31:58,010
các thứ xảy ra trong QML do ta

567
00:31:58,010 --> 00:32:02,269
đã phát signal. Khi mọi người hỏi tôi

568
00:32:02,269 --> 00:32:05,330
về cách điều khiển các item QML từ

569
00:32:05,330 --> 00:32:08,210
C++ thì điều thật sự muốn thực hiện từ

570
00:32:08,210 --> 00:32:10,760
quan điểm thiết kế, không phải là tìm các item

571
00:32:10,760 --> 00:32:12,679
và điều khiển chúng, mà là bạn sẽ muốn

572
00:32:12,679 --> 00:32:14,450
thiết kế phần back-end của bạn để phát ra

573
00:32:14,450 --> 00:32:17,419
những signal đúng, để thay đổi trạng thái và cho

574
00:32:17,419 --> 00:32:19,700
giao diện người dùng (user interface) quyết định

575
00:32:19,700 --> 00:32:21,590
thay đổi đó là gì. Trong trạng thái đó có ý nghĩa gì cho

576
00:32:21,590 --> 00:32:24,039
giao diện người dùng.

577
00:32:34,480 --> 00:32:37,780
Nếu bạn muốn thêm các callback

578
00:32:37,780 --> 00:32:40,740
thì về cơ bản là ta muốn các slot mà ta có thể gọi

579
00:32:40,740 --> 00:32:46,620
từ QML. Việc này cũng dễ như tạo ra

580
00:32:46,620 --> 00:32:52,630
các slot trong C++. Bạn có lựa chọn của bạn nên

581
00:32:52,630 --> 00:32:55,480
khi vùng có con trỏ chuột ở đây được nhấn (click) thì

582
00:32:55,480 --> 00:32:58,710
tức là ta muốn gọi setColor cho

583
00:32:58,710 --> 00:33:07,270
đối tượng của ta để phủ màu.

584
00:33:07,270 --> 00:33:10,680
Điều ta có thể làm là ta có thể có

585
00:33:10,680 --> 00:33:14,050
slot mới tên là setColor và bạn sẽ nhận thấy

586
00:33:14,050 --> 00:33:20,740
nó nhận vào QColor. Bây giờ,

587
00:33:20,740 --> 00:33:22,810
điều hay về QColor là nó

588
00:33:22,810 --> 00:33:25,840
có một sự chuyển đổi ngầm từ xâu kí tự.

589
00:33:25,840 --> 00:33:30,640
Nên ta có thể truyền vào màu xanh đậm (darkgreen), rồi khi

590
00:33:30,640 --> 00:33:32,860
nó được gọi trong C++ thì darkgreen

591
00:33:32,860 --> 00:33:35,500
sẽ được truyền vào một cấu trúc sao chép (copy constructor) ngầm

592
00:33:35,500 --> 00:33:38,140
cho QColor, và ta sẽ

593
00:33:38,140 --> 00:33:42,970
tạo màu từ "darkgreen". Vậy

594
00:33:42,970 --> 00:33:44,800
bạn có lựa chọn của bạn trong việc xác định

595
00:33:44,800 --> 00:33:48,580
các public slot hay sử dụng macro Q_INVOKABLE.

596
00:33:48,580 --> 00:33:58,570
Vâng, điều đầu tiên

597
00:33:58,570 --> 00:34:00,730
giống thứ này nên là slot.

598
00:34:00,730 --> 00:34:02,620
Là một lập trình viên Qt có kinh nghiệm thì

599
00:34:02,620 --> 00:34:05,170
bạn sẽ biết cái nào nên

600
00:34:05,170 --> 00:34:07,270
là slot, giống như setColor là một

601
00:34:07,270 --> 00:34:09,940
ứng viên tốt để làm slot. Còn thứ

602
00:34:09,940 --> 00:34:12,400
mà bạn sẽ thực hiện giống như hàm,

603
00:34:12,400 --> 00:34:14,530
mà sẽ trả về một giá trị thì không phải là

604
00:34:14,530 --> 00:34:16,420
ứng viên tốt cho slot, nhưng nó có thể

605
00:34:16,420 --> 00:34:18,040
là ứng viên tốt cho thứ gì đó

606
00:34:18,040 --> 00:34:20,590
được gọi từ QML như getMeSomeValue.

607
00:34:20,590 --> 00:34:24,190
Trong trường hợp đó, tôi sẽ sử dụng getMeSomeValue

608
00:34:24,190 --> 00:34:26,110
với Q_INVOKABLE ở trước

609
00:34:26,110 --> 00:34:27,969
nó, trước khi ai đó nghĩ rằng họ

610
00:34:27,969 --> 00:34:30,340
có thể kết nốt một signal C++ thông thường với

611
00:34:30,340 --> 00:34:32,679
thứ này và trở thành thứ

612
00:34:32,679 --> 00:34:35,549
làm việc với hàm này.

613
00:34:51,130 --> 00:34:59,350
Ta cũng có thể thêm vài method

614
00:34:59,350 --> 00:35:01,330
sử dụng Q_INVOKABLE như

615
00:35:01,330 --> 00:35:03,250
method randomColor ở đây, tại chỗ mà ta đang

616
00:35:03,250 --> 00:35:05,500
thiết lập parent.color thành parent.randomColor,

617
00:35:05,500 --> 00:35:09,580
parent là một ellipse. Vậy

618
00:35:09,580 --> 00:35:13,480
việc lưu QColor là trong C++ và ta

619
00:35:13,480 --> 00:35:16,540
đang sử dụng một hàm trả về một kiểu.

620
00:35:16,540 --> 00:35:19,000
Ở đây, việc chứa color thật ra

621
00:35:19,000 --> 00:35:21,580
không có ích như slot. Ta sử dụng

622
00:35:21,580 --> 00:35:25,150
macro Q_INVOKABLE rồi trả về

623
00:35:25,150 --> 00:35:28,630
QColor và randomColor. Thế là xong. Bây giờ

624
00:35:28,630 --> 00:35:30,670
meta-object system sẽ tìm

625
00:35:30,670 --> 00:35:32,590
macro đó, thêm nó vào danh sách những hàm

626
00:35:32,590 --> 00:35:36,370
có thể gọi được và giờ thì nó xuất hiện trong QML.

627
00:35:36,370 --> 00:35:39,820
Dòng lệnh này sẽ chạy khi có click,

628
00:35:39,820 --> 00:35:47,740
onClicked: parent.color = parent.randomColor. Và randomColor

629
00:35:47,740 --> 00:35:52,120
ở đây được thực hiện để dùng màu ngẫu nhiên nào đó.

630
00:35:52,120 --> 00:35:56,380
Thật ra không có gì để nói về nó.

631
00:35:56,380 --> 00:36:04,180
Ta hãy tưởng tượng rằng ta có thể

632
00:36:04,180 --> 00:36:07,510
định nghĩa (define) các signal giống như trong C++,

633
00:36:07,510 --> 00:36:10,360
và chúng sử dụng được trong QML. Ta có thể

634
00:36:10,360 --> 00:36:13,150
define các slot giống như trong C++,

635
00:36:13,150 --> 00:36:16,270
có thể sử dụng được trong QML. Ta có thể define

636
00:36:16,270 --> 00:36:18,220
các hàm và cho chúng sử dụng

637
00:36:18,220 --> 00:36:22,710
macro Q_INVOKABLE rồi chúng có thể sử dụng được từ QML.

638
00:36:25,770 --> 00:36:30,540
Ai có câu hỏi gì không?

639
00:36:35,410 --> 00:36:40,970
Định nghĩa kiểu của thuộc tính có tùy chỉnh
(Defining Custom Property Types).

640
00:36:40,970 --> 00:36:42,980
Bạn có thể đoán đó là những kiểu như float (kiểu số thực),

641
00:36:42,980 --> 00:36:46,279
boolean (kiểu logic), string (xâu kí tự), và color. Nhưng

642
00:36:46,279 --> 00:36:48,049
nếu ta muốn kiểu nào đó

643
00:36:48,049 --> 00:36:52,609
phức tạp hơn như item hay

644
00:36:52,609 --> 00:36:55,039
QObject khác mà bên trong nó có nhiều

645
00:36:55,039 --> 00:36:58,690
thuộc tính hoặc có thể ta muốn sử dụng enum

646
00:36:58,690 --> 00:37:05,690
từ C++. Ví dụ, ta muốn tạo

647
00:37:05,690 --> 00:37:10,760
ellipse có thuộc tính style, trong đó style

648
00:37:10,760 --> 00:37:15,710
không phải là enum như Outline. Bạn sẽ thấy

649
00:37:15,710 --> 00:37:18,200
những thuộc tính này được phân tán khắp QtQuick,

650
00:37:18,200 --> 00:37:19,910
trong đó bạn có thể gọi giống cú pháp text.[gì đó].

651
00:37:19,910 --> 00:37:22,250
Bạn có thể tạo ellipse.[gì đó] của riêng bạn

652
00:37:22,250 --> 00:37:28,069
mà là kiểu enum và điều này

653
00:37:28,069 --> 00:37:31,039
thật sự khá dễ bởi vì mọi thứ bạn

654
00:37:31,039 --> 00:37:34,180
cần sử dụng là macro Q_PROPERTY và

655
00:37:34,180 --> 00:37:41,059
Q_ENUMS. Đây thật ra là một

656
00:37:41,059 --> 00:37:44,420
macro cũ đã có cả thập kỉ rồi,

657
00:37:44,420 --> 00:37:46,789
mà có thể là lâu hơn. Nó được sử dụng trong

658
00:37:46,789 --> 00:37:49,220
các plugin. Đó là cách mà nhà thiết kế

659
00:37:49,220 --> 00:37:51,500
biết khi nào bạn có trong

660
00:37:51,500 --> 00:37:54,529
cây thuộc tính là

661
00:37:54,529 --> 00:37:57,319
tôi muốn frame được vẽ theo style nào.

662
00:37:57,319 --> 00:38:00,049
Nó nhận xâu kí tự để

663
00:38:00,049 --> 00:38:03,529
hiển thị từ macro Q_ENUMS này. Điều nó

664
00:38:03,529 --> 00:38:06,349
thực hiện là trình biên dịch đối tượng biến đổi
(meta-object compiler)

665
00:38:06,349 --> 00:38:08,450
sẽ đọc header file của bạn và

666
00:38:08,450 --> 00:38:10,760
tìm kiếm enum tên là Style.

667
00:38:10,760 --> 00:38:13,609
Sau đó, nó sẽ thực hiện ánh xạ

668
00:38:13,609 --> 00:38:18,500
xâu kí tự tên của

669
00:38:18,500 --> 00:38:20,809
enum với kiểu const, integer và

670
00:38:20,809 --> 00:38:23,450
duy trì ánh xạ đó. Nên bạn có thể chuyển đổi sang hoặc

671
00:38:23,450 --> 00:38:26,329
từ xâu kí tự và điều đó giống y hệt

672
00:38:26,329 --> 00:38:28,460
chức năng mà QML sử dụng để

673
00:38:28,460 --> 00:38:31,670
chuyển đổi Outline và Filled thành

674
00:38:31,670 --> 00:38:34,130
ellipse.Outline và ellipse.Filled.

675
00:38:34,130 --> 00:38:36,349
Những thứ này không phải là 0 và 1 mà chúng

676
00:38:36,349 --> 00:38:42,349
thật sự khớp nhau. Nên một khi bạn sử dụng

677
00:38:42,349 --> 00:38:45,950
macro Q_ENUMS thì bạn có thể sử dụng Q_ENUMS. Bạn

678
00:38:45,950 --> 00:38:47,420
có thể sử dụng Qt Style để

679
00:38:47,420 --> 00:38:50,570
có một kiểu trong macro Q_PROPERTY và kiểu này

680
00:38:50,570 --> 00:38:57,920
sẽ hoạt động. Bạn chỉ cần có style

681
00:38:57,920 --> 00:39:00,440
và setStyle, biến lưu trữ nào đó và

682
00:39:00,440 --> 00:39:02,890
signal.

683
00:39:09,849 --> 00:39:13,329
Giống như trong C++, giống như

684
00:39:13,329 --> 00:39:15,549
setColor thì những gì bạn cần là một getter và

685
00:39:15,549 --> 00:39:17,799
setter. Và hãy đảm bảo là bạn set hay gọi

686
00:39:17,799 --> 00:39:21,130
update rồi emit đúng signal

687
00:39:21,130 --> 00:39:23,519
giống như cách ta đã thực hiện với color.

688
00:39:23,519 --> 00:39:30,789
Ngoại trừ bây giờ ta có enum. Có thể enum

689
00:39:30,789 --> 00:39:34,239
thì chưa đủ cụ thể. Có thể ta muốn

690
00:39:34,239 --> 00:39:39,009
đổi với những item khai báo khác. Ta muốn

691
00:39:39,009 --> 00:39:42,459
thiết lập Style bằng cách truyền một instance

692
00:39:42,459 --> 00:39:45,849
của class style, là một class khác

693
00:39:45,849 --> 00:39:48,219
mà ta sẽ export. Như vậy bạn

694
00:39:48,219 --> 00:39:50,349
có thể tạo ra các instance của ellipse. Bạn có thể

695
00:39:50,349 --> 00:39:53,109
tạo ra instance của một style trong khi style

696
00:39:53,109 --> 00:39:54,880
là một item không thấy được. Nó chỉ là một

697
00:39:54,880 --> 00:39:58,900
tập dữ liệu. Vậy làm thế nào ta có thể thực hiện

698
00:39:58,900 --> 00:40:02,339
việc này? Nó phức tạp hơn một chút.

699
00:40:02,339 --> 00:40:07,920
Rõ ràng chúng ta cũng sử dụng Shapes 7.0,

700
00:40:08,759 --> 00:40:14,890
nhưng điều bạn có thể làm là khai báo

701
00:40:14,890 --> 00:40:19,329
QDeclarativeItem khác. Và lần này

702
00:40:19,329 --> 00:40:21,400
ta sẽ để cho nó dùng giá trị mặc định

703
00:40:21,400 --> 00:40:23,440
để bản thân nó không tự vẽ. Bởi vì đây chỉ là

704
00:40:23,440 --> 00:40:25,959
dữ liệu và ta sẽ thực hiện hai

705
00:40:25,959 --> 00:40:29,109
thuộc tính Color và Filled, rồi ta

706
00:40:29,109 --> 00:40:31,209
thực hiện hai thuộc tính đó giống như ellipse. Như vậy

707
00:40:31,209 --> 00:40:34,089
ta đang tạo ra một class style và một

708
00:40:34,089 --> 00:40:41,559
class ellipse. Rồi ta sẽ

709
00:40:41,559 --> 00:40:45,670
có style và setStyle. Bây giờ, điều

710
00:40:45,670 --> 00:40:47,349
khiến cho việc này

711
00:40:47,349 --> 00:40:49,959
hấp dẫn hơn và khác với lập trình C++

712
00:40:49,959 --> 00:40:52,329
là ta đang truyền vào

713
00:40:52,329 --> 00:40:56,759
các con trỏ ở đây rồi chúng ta lấy các con trỏ.

714
00:40:56,759 --> 00:41:00,249
Nói chung, trong C++, bạn sẽ trả về một

715
00:41:00,249 --> 00:41:02,349
bản sao và bạn lấy một tham chiếu hằng số (const).

716
00:41:02,349 --> 00:41:07,499
Cái này sẽ xử lý trong các con trỏ và

717
00:41:07,499 --> 00:41:10,859
Q_PROPERTY sẽ là kiểu

718
00:41:10,859 --> 00:41:14,319
con trỏ style và tên nó sẽ là

719
00:41:14,319 --> 00:41:17,799
style, READ là style, WRITE là setStyle,

720
00:41:17,799 --> 00:41:22,079
và NOTIFY là styleChanged.

721
00:41:23,400 --> 00:41:26,349
Vậy khi ta thực hiện thuộc tính này thì ta có thể

722
00:41:26,349 --> 00:41:29,380
điều chỉnh paint mà thật ra là sử dụng style

723
00:41:29,380 --> 00:41:30,789
và quyết định khi nào bạn sẽ được

724
00:41:30,789 --> 00:41:32,409
filled. Và màu nào bạn sẽ sử dụng

725
00:41:32,409 --> 00:41:34,569
là dựa vào nội dung của đối tượng style đó.

726
00:41:34,569 --> 00:41:39,309
Vậy điều ta cần làm là ta cần

727
00:41:39,309 --> 00:41:43,059
đăng kí trong hàm main không phải một kiểu mà là hai

728
00:41:43,059 --> 00:41:46,029
kiểu style và item ellipse.

729
00:41:46,029 --> 00:41:59,819
Một khi ta thực hiện chừng đó việc

730
00:42:01,319 --> 00:42:10,799
thì đoạn code này sẽ thật sự hoạt động. Vâng?

731
00:42:13,620 --> 00:42:27,990
Tôi nghĩ đó có thể là. Vâng, vâng, có thể.

732
00:42:27,990 --> 00:42:32,720
Vâng.

733
00:42:41,220 --> 00:42:43,170
Câu hỏi hay. Bây giờ bạn dính vào

734
00:42:43,170 --> 00:42:48,060
tranh cãi. Theo chủ nghĩa thuần túy thì

735
00:42:48,060 --> 00:42:51,870
quan điểm là kiểu là kiểu

736
00:42:51,870 --> 00:42:53,640
và thực tế đó là một con trỏ

737
00:42:53,640 --> 00:42:57,090
mà thật ra thuộc về tên của

738
00:42:57,090 --> 00:43:00,000
biến. Bởi vì nếu bạn sử dụng ký pháp (notation) thông thường

739
00:43:00,000 --> 00:43:03,330
thì đây là

740
00:43:03,330 --> 00:43:04,860
một khai báo hàm. Nhưng nếu bạn

741
00:43:04,860 --> 00:43:08,090
tạo ra các biến và bạn có

742
00:43:08,090 --> 00:43:11,730
style * [tên] . gì đó, nếu không thì

743
00:43:11,730 --> 00:43:13,380
bạn đã tạo ra 2 instance trong một dòng lệnh,

744
00:43:13,380 --> 00:43:15,360
mà trong đó sẽ không tạo ra

745
00:43:15,360 --> 00:43:17,490
2 con trỏ mà một cái là

746
00:43:17,490 --> 00:43:18,900
con trỏ và cái khác là

747
00:43:18,900 --> 00:43:22,680
stack instance. Có vài người

748
00:43:22,680 --> 00:43:27,240
thích đặt kí tự * sau khi gõ

749
00:43:27,240 --> 00:43:31,770
[dấu cách] * thì đối tượng

750
00:43:31,770 --> 00:43:34,800
thật sự là style. Tôi thì dùng

751
00:43:34,800 --> 00:43:37,170
kí tự * sau tên kiểu và tôi không cho

752
00:43:37,170 --> 00:43:40,010
hai thứ vào trong một dòng lệnh.

753
00:43:46,580 --> 00:43:54,720
Câu hỏi hay. Tôi thật sự không chắc

754
00:43:54,720 --> 00:43:59,340
về điều đó. Đó là gì vậy?

755
00:43:59,340 --> 00:44:03,660
Ồ, nó bắt buộc kí tự * đi kèm

756
00:44:03,660 --> 00:44:10,800
với style. Vâng, tôi

757
00:44:10,800 --> 00:44:12,450
thực sự không chắc về điều đó. Đó là một câu hỏi hay.

758
00:44:12,450 --> 00:44:19,470
Hoặc nếu ta sẽ dùng

759
00:44:19,470 --> 00:44:23,150
cả cách đó thì tôi sẽ phải tìm hiểu điều đó.

760
00:44:37,460 --> 00:44:40,059
Vâng.

761
00:44:45,340 --> 00:44:49,090
Câu hỏi nữa cũng không vấn đề gì. Có thể tôi muốn

762
00:44:49,090 --> 00:44:51,670
có một thuộc tính mà thật ra là một

763
00:44:51,670 --> 00:44:54,580
danh sách. Giống như ta có một mảng

764
00:44:54,580 --> 00:45:00,100
các style cùng một mảng những biến đổi. Có thể

765
00:45:00,100 --> 00:45:02,980
tôi muốn có một đối tượng biểu đồ (chart object) và

766
00:45:02,980 --> 00:45:07,000
đối tượng biểu đồ đó có một danh sách các thanh. Vậy

767
00:45:07,000 --> 00:45:11,410
ta sẽ thực hiện điều này từ C++ như nào?

768
00:45:11,410 --> 00:45:13,870
Nó khá dễ bởi vì ta có một kiểu thuộc tính

769
00:45:13,870 --> 00:45:17,140
đặc biệt mà sẽ là

770
00:45:17,140 --> 00:45:21,760
QDeclarativeListProperty. Nên ở đây

771
00:45:21,760 --> 00:45:25,200
ta sẽ sử dụng cú pháp Q_PROPERTY,

772
00:45:25,200 --> 00:45:28,420
trong đó kiểu của ta thật ra sẽ là

773
00:45:28,420 --> 00:45:31,750
một mẫu mà là QDeclarativeListProperty

774
00:45:31,750 --> 00:45:34,420
và ta cho nó kiểu

775
00:45:34,420 --> 00:45:38,980
mà danh sách này sẽ chứa. Và

776
00:45:38,980 --> 00:45:41,260
nó sẽ được gọi là bars. Nó

777
00:45:41,260 --> 00:45:45,010
đọc hàm bars và nó có

778
00:45:45,010 --> 00:45:52,090
NOTIFY barsChanged. Và điều ta sẽ

779
00:45:52,090 --> 00:45:54,700
hiểu ra ở đây là trong thực tế

780
00:45:54,700 --> 00:45:57,280
bars sẽ có quyền đọc

781
00:45:57,280 --> 00:46:00,580
mặc dù ta không có hàm write.

782
00:46:00,580 --> 00:46:03,370
Và lý do cho điều đó là

783
00:46:03,370 --> 00:46:06,760
hàm read trả về một danh sách chứ không phải

784
00:46:06,760 --> 00:46:08,560
là nội dung của danh sách. Nên ta có thể

785
00:46:08,560 --> 00:46:10,360
điều khiển danh sách sau khi ta có

786
00:46:10,360 --> 00:46:13,560
kết quả từ hàm read.

787
00:46:26,930 --> 00:46:45,910
Vâng, được rồi.

788
00:46:57,470 --> 00:46:59,760
Vâng, tôi không nghĩ vậy. Bởi vì

789
00:46:59,760 --> 00:47:04,290
bản thân các item cần phải

790
00:47:04,290 --> 00:47:08,760
bị loại bỏ bởi QML. Hãy tưởng tượng nếu

791
00:47:08,760 --> 00:47:11,850
có tình huống trong đó bạn set 3

792
00:47:11,850 --> 00:47:12,960
style trong một dòng

793
00:47:12,960 --> 00:47:14,670
hoặc bạn liên tục thay đổi style bởi vì

794
00:47:14,670 --> 00:47:17,130
bạn giữ click chuột vào nó giống như bạn không thể

795
00:47:17,130 --> 00:47:18,720
để chúng nghỉ,

796
00:47:18,720 --> 00:47:20,100
đợi parent của chúng kết thúc.

797
00:47:20,100 --> 00:47:22,670
Đó sẽ là kết thúc của ứng dụng.

798
00:47:22,670 --> 00:47:25,800
Vậy có lời khuyên là nó sẽ thực hiện

799
00:47:25,800 --> 00:47:28,950
quản lý sau khi bạn gọi nó, nó sẽ

800
00:47:28,950 --> 00:47:36,270
xóa. Và điều đó sẽ

801
00:47:36,270 --> 00:47:42,320
yêu cầu giữ lại.

802
00:47:49,720 --> 00:47:52,450
Ta tạo class ChartItem này để

803
00:47:52,450 --> 00:47:57,040
sử dụng các BarItem và ta có

804
00:47:57,040 --> 00:48:00,330
QList của các con trỏ BarItem.

805
00:48:00,330 --> 00:48:05,710
Ta sẽ có hàm static append_bar

806
00:48:05,710 --> 00:48:10,480
mà sẽ nhận vào

807
00:48:10,480 --> 00:48:14,860
list và BarItem để nối vào

808
00:48:14,860 --> 00:48:21,820
Sau đó trong hàm bars

809
00:48:21,820 --> 00:48:24,970
mà là hàm đọc, ta sẽ chỉ việc

810
00:48:24,970 --> 00:48:28,660
tiếp tục rồi trả về

811
00:48:28,660 --> 00:48:33,190
QDeclarativeListProperty. Và

812
00:48:33,190 --> 00:48:34,690
QDeclarativeListProperty thì hơi phức tạp

813
00:48:34,690 --> 00:48:36,970
do nó là một template. Cho nên

814
00:48:36,970 --> 00:48:38,620
nó nhận vào kiểu mà nó chứa.

815
00:48:38,620 --> 00:48:43,780
Nó nhận vào một con trỏ

816
00:48:43,780 --> 00:48:47,650
cho parent và nó nhận vào một con trỏ hàm

817
00:48:47,650 --> 00:48:51,250
để nối vào. Như vậy đó là cách mà nó

818
00:48:51,250 --> 00:48:56,470
sẽ biết khi bạn gọi BAR, BAR, BAR,

819
00:48:56,470 --> 00:48:58,660
Đó là cách nó sẽ nối vào

820
00:48:58,660 --> 00:49:01,740
danh sách (list).

821
00:49:10,280 --> 00:49:15,290
Trong append_bar, điều ta làm là ta thiết lập

822
00:49:15,290 --> 00:49:17,000
parent để ta sẽ

823
00:49:17,000 --> 00:49:18,650
nhận sự sở hữu của item này.

824
00:49:18,650 --> 00:49:20,810
Ta có thể sắp xếp nó một cách chính xác. Ta sẽ

825
00:49:20,810 --> 00:49:23,660
nối vào các đối tượng bars và

826
00:49:23,660 --> 00:49:27,760
ta sẽ bỏ qua barsChanged.

827
00:49:35,970 --> 00:49:40,350
Điều ta vừa tìm hiểu là cách tạo ra một

828
00:49:40,350 --> 00:49:42,930
QDeclarativeItem mà có thể là

829
00:49:42,930 --> 00:49:45,840
instance và thấy hình ellipse trên màn hình.

830
00:49:45,840 --> 00:49:48,930
Ta vừa tìm hiểu cách ta có thể export

831
00:49:48,930 --> 00:49:51,810
những thuộc tính thành các enum. Ta vừa tìm hiểu cách

832
00:49:51,810 --> 00:49:58,560
ta có thể export các sub item, nên

833
00:49:58,560 --> 00:50:03,000
ellipse có item style. Ta cũng tìm hiểu

834
00:50:03,000 --> 00:50:06,480
cách để ta có thể có item thấy được, có

835
00:50:06,480 --> 00:50:08,910
những item thấy được khác và quản lý chúng trong một

836
00:50:08,910 --> 00:50:12,920
danh sách giống như biểu đồ có một loạt các thanh (bar)

837
00:50:12,920 --> 00:50:15,840
bằng việc sử dụng QDeclarativeListProperty,

838
00:50:15,840 --> 00:50:18,600
mà là một điều khá phức tạp và

839
00:50:18,600 --> 00:50:20,610
bạn biết là cần con trỏ hàm để

840
00:50:20,610 --> 00:50:24,510
nối vào. Nhưng thông thường thì sử dụng

841
00:50:24,510 --> 00:50:28,110
cùng một cú pháp Q_PROPERTY như mọi thứ

842
00:50:28,110 --> 00:50:31,980
khác. Điều cuối cùng mà ta sẽ

843
00:50:31,980 --> 00:50:36,290
bàn là cách lấy các item C++

844
00:50:36,290 --> 00:50:40,500
rồi đặt chúng vào một module, giống như

845
00:50:40,500 --> 00:50:43,050
ta có module line item. Ta sẽ

846
00:50:43,050 --> 00:50:45,300
tạo ra module Shapes.

847
00:50:45,300 --> 00:50:49,920
Thay vì export các kiểu từ hàm main

848
00:50:49,920 --> 00:50:52,830
thì ta sẽ để cho vài đối tượng được chia sẻ

849
00:50:52,830 --> 00:50:55,290
lo về vấn đề đó. Và giống như việc Qt quét

850
00:50:55,290 --> 00:50:57,150
những thư mục nhất định rồi lấy tất cả

851
00:50:57,150 --> 00:50:59,190
sequel driver cùng toàn bộ image driver.

852
00:50:59,190 --> 00:51:01,320
Nó sẽ quét những thư mục nhất định

853
00:51:01,320 --> 00:51:09,300
và tìm trong QML các plugin C++. Đó là

854
00:51:09,300 --> 00:51:11,430
điều bạn có thể làm với từng plug-in

855
00:51:11,430 --> 00:51:12,180
trong Qt.

856
00:51:12,180 --> 00:51:14,520
Bạn có thể chỉ việc thừa kế từ

857
00:51:14,520 --> 00:51:18,330
QDeclarativeExtensionPlugin cùng ý tưởng

858
00:51:18,330 --> 00:51:21,630
như QImageFormatPlugin hay

859
00:51:21,630 --> 00:51:25,320
QSequelDriverPlugin. Và nó cần

860
00:51:25,320 --> 00:51:27,570
sử dụng macro Q_OBJECT và cần

861
00:51:27,570 --> 00:51:30,330
thực hiện một hàm tên là registerTypes.

862
00:51:30,330 --> 00:51:37,020
Và điều xảy ra trong registerTypes

863
00:51:37,020 --> 00:51:40,230
là điều bạn đã sử dụng trong hàm main. Cho nên

864
00:51:40,230 --> 00:51:42,720
bạn sẽ có qmlRegisterType<EllipseItem>.

865
00:51:42,720 --> 00:51:47,790
Bạn sẽ truyền vào uri.

866
00:51:47,790 --> 00:51:49,960
Lý do tại sao tham số này

867
00:51:49,960 --> 00:51:54,339
được truyền vào là vì bản kê trong QML (QML manifest)

868
00:51:54,339 --> 00:51:57,570
sẽ định nghĩa tham số đó và

869
00:51:57,570 --> 00:52:00,609
tại chỗ bạn được xác định trong hệ thống tập tin

870
00:52:00,609 --> 00:52:03,490
thì sẽ định nghĩa tên của

871
00:52:03,490 --> 00:52:08,020
gói (package) là gì. Bạn xác định số phiên bản ở đây.

872
00:52:08,020 --> 00:52:11,589
Ta đã lên tới 9.0 và ta có tên của

873
00:52:11,589 --> 00:52:14,500
item sẽ là ellipse. Bây giờ để

874
00:52:14,500 --> 00:52:16,180
chính xác toàn bộ thì ta nên

875
00:52:16,180 --> 00:52:18,640
có 2 register. Ta nên đăng ký

876
00:52:18,640 --> 00:52:23,910
item ellipse và đăng ký item style.

877
00:52:24,690 --> 00:52:28,900
Rồi ta cũng phải sử dụng magic export plugin.

878
00:52:28,900 --> 00:52:31,720
Giống như mọi plugin khác,

879
00:52:31,720 --> 00:52:33,099
plugin này sẽ mở rộng để thấy

880
00:52:33,099 --> 00:52:35,380
những symbol mà Qt sẽ sử dụng để

881
00:52:35,380 --> 00:52:37,510
tìm trong đối tượng được chia sẻ để lấy được

882
00:52:37,510 --> 00:52:44,470
điểm vào (entry point) để gọi registerTypes.

883
00:52:44,470 --> 00:52:46,510
Nếu bạn muốn build đoạn này thành một thư viện

884
00:52:46,510 --> 00:52:49,060
được chia sẻ thì bạn có thể sử dụng vài thứ

885
00:52:49,060 --> 00:52:52,510
trong các dòng của project file này. Ta có một

886
00:52:52,510 --> 00:52:56,410
mẫu thư viện mà ta cần báo cho

887
00:52:56,410 --> 00:52:59,580
biến CONFIG đó là qt plugin.

888
00:52:59,580 --> 00:53:02,230
Tất nhiên, ta cần sử dụng HEADERS, SOURCES

889
00:53:02,230 --> 00:53:05,740
và khả năng là DESTDIR để thả

890
00:53:05,740 --> 00:53:10,450
đối tượng được chia sẻ ở chỗ nào đó có ích.

891
00:53:10,450 --> 00:53:17,800
Ta quay lại

892
00:53:17,800 --> 00:53:21,849
chỗ ta có thư mục plugins và

893
00:53:21,849 --> 00:53:24,220
thư mục standalone và ta có

894
00:53:24,220 --> 00:53:27,609
qmldir. qmldir là một

895
00:53:27,609 --> 00:53:30,160
bản kê khai và ta thấy rằng qmldir có thể

896
00:53:30,160 --> 00:53:33,420
xác định các tập tin QML. Ta cũng có thể xác định

897
00:53:33,420 --> 00:53:37,240
các plugin sharedObject để load khi bạn

898
00:53:37,240 --> 00:53:41,589
load import này. Cách bạn làm việc đó

899
00:53:41,589 --> 00:53:45,970
là bạn xác định một dòng lệnh phụ trong QML

900
00:53:45,970 --> 00:53:50,050
mà gọi plugin ellipse. Plugin

901
00:53:50,050 --> 00:53:52,030
là tên của đối tượng được chia sẻ

902
00:53:52,030 --> 00:53:54,250
mà không có [.], nên cuối cùng là

903
00:53:54,250 --> 00:53:57,160
thư mục tìm đối tượng được chia sẻ đó trong

904
00:53:57,160 --> 00:53:59,890
đường dẫn tương đối (relative path). Nó có thể là,

905
00:53:59,890 --> 00:54:02,619
trong trường hợp này là ../plugins.

906
00:54:02,619 --> 00:54:04,490
Nó có thể ở trong

907
00:54:04,490 --> 00:54:10,850
đường dẫn tương đối của plugins nên trong qmldir

908
00:54:10,850 --> 00:54:13,580
bạn có thể có một đống tập tin QML,

909
00:54:13,580 --> 00:54:20,480
cùng một hay nhiều plugins C++. Và với

910
00:54:20,480 --> 00:54:23,510
người dùng import package đó thì

911
00:54:23,510 --> 00:54:25,190
họ không bao giờ chắc chắc cái nào

912
00:54:25,190 --> 00:54:27,770
được thực hiện trong QML và cái nào là trong C++.

913
00:54:27,770 --> 00:54:36,050
Nó coi mọi thứ như nhau.

914
00:54:36,050 --> 00:54:41,930
Đây là một ví dụ về việc sử dụng

915
00:54:41,930 --> 00:54:49,520
ellipse. Và nếu qmldir và ellipse9s

916
00:54:49,520 --> 00:54:53,240
là trong cùng một thư mục thì

917
00:54:53,240 --> 00:54:55,280
bạn không cần import

918
00:54:55,280 --> 00:54:57,380
module của riêng bạn. Nó chiếm khá nhiều

919
00:54:57,380 --> 00:55:01,430
trong slide này bởi vì ellipse9s

920
00:55:01,430 --> 00:55:03,500
thực chất là một tập tin QML mà được

921
00:55:03,500 --> 00:55:07,120
phân bổ cùng plugin của ta.

922
00:55:13,520 --> 00:55:19,109
Cho nên bạn có thể load những plugin này

923
00:55:19,109 --> 00:55:23,270
cho bản thân bạn bằng việc sử dụng QPluginLoader hay

924
00:55:23,270 --> 00:55:27,990
bạn có thể chỉ việc điều khiển đường dẫn import của QML

925
00:55:27,990 --> 00:55:31,380
bằng cách điều khiển các hàm static

926
00:55:31,380 --> 00:55:34,920
trong QApplication hay thiết lập

927
00:55:34,920 --> 00:55:39,020
biến môi trường cho đường dẫn import của QML.

928
00:55:51,170 --> 00:55:56,180
Những mở rộng (extension) mà bạn viết trong C++

929
00:55:56,180 --> 00:55:58,460
có thể được biên dịch thành các plugin. Chúng có thể

930
00:55:58,460 --> 00:56:01,130
được bọc cùng các tập tin QML khác, và chúng

931
00:56:01,130 --> 00:56:05,800
có thể được importe thành một package siêu lớn (gigantic)

932
00:56:05,800 --> 00:56:09,530
nếu bạn điều khiển đường dẫn import của QML hay

933
00:56:09,530 --> 00:56:14,300
sử dụng cờ (flag) -i cho QML viewer. Cảm ơn.

934
00:56:14,300 --> 00:56:18,530
Bạn sẽ thấy những item này nên bạn không

935
00:56:18,530 --> 00:56:21,500
cần có C++ wrapper. Nếu bạn sử dụng

936
00:56:21,500 --> 00:56:24,110
các plugin thì bạn có thể lấy code C++

937
00:56:24,110 --> 00:56:26,840
để chạy từ QML viewer mà là

938
00:56:26,840 --> 00:56:30,920
một cách hay. Bạn có thể load trực tiếp các plugin

939
00:56:30,920 --> 00:56:34,540
bằng QPluginLoader hoặc bạn có thể để

940
00:56:34,540 --> 00:56:37,580
Qt tự động load các plugin bằng

941
00:56:37,580 --> 00:56:46,820
đường dẫn import của QML mà đưa ta tới

942
00:56:46,820 --> 00:00:00,000
kết thúc phần trình bày của tôi.

